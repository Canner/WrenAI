import { Knex } from 'knex';
import {
  BaseRepository,
  IBasicRepository,
  IQueryOptions,
} from './baseRepository';
import {
  camelCase,
  snakeCase,
  Dictionary,
  isPlainObject,
  mapKeys,
  mapValues,
} from 'lodash';
import { AskResultStatus, WrenAIError } from '../adaptors/wrenAIAdaptor';
import { ExplainType } from './threadResponseExplainRepository';

export interface SQLLocation {
  line: number;
  column: number;
}
export interface ThreadResponseReference {
  id: number;
  type: ExplainType;
  sqlSnippet: string;
  sqlLocation: any;
}
export interface DetailStep {
  summary: string;
  sql: string;
  cteName: string;
  references?: ThreadResponseReference[];
}

export interface ThreadResponseDetail {
  viewId?: number;
  description: string;
  steps: Array<DetailStep>;
}

export interface PrevCorrection {
  id: number;
  type: string;
  correction: string;
}

export interface ThreadResponse {
  id: number; // ID
  threadId: number; // Reference to thread.id
  queryId: string; // Thread response query ID
  question: string; // Thread response question
  summary: string; // Summary comes from the user's original question
  status: string; // Thread response status
  detail: ThreadResponseDetail; // Thread response detail
  error: object; // Thread response error
  corrections: PrevCorrection[]; // Previous thread response corrections
}

export interface ThreadResponseWithThreadContext extends ThreadResponse {
  threadSummary: string; // Thread summary is generated by AI first, and can be updated by the user
  sql: string;
}

export interface IThreadResponseRepository
  extends IBasicRepository<ThreadResponse> {
  getResponsesWithThread(
    threadId: number,
    limit?: number,
  ): Promise<ThreadResponseWithThreadContext[]>;
}

export class ThreadResponseRepository
  extends BaseRepository<ThreadResponse>
  implements IThreadResponseRepository
{
  constructor(knexPg: Knex) {
    super({ knexPg, tableName: 'thread_response' });
  }

  public async getResponsesWithThread(threadId: number, limit?: number) {
    const query = this.knex(this.tableName)
      .select('thread_response.*')
      .select('thread.sql as sql')
      .select('thread.summary as thread_summary')
      .where({ thread_id: threadId })
      .leftJoin('thread', 'thread.id', 'thread_response.thread_id');

    if (limit) {
      query.orderBy('created_at', 'desc').limit(limit);
    }

    return (await query).map((res) =>
      this.transformFromDBData(res),
    ) as ThreadResponseWithThreadContext[];
  }

  public async updateOne(
    id: string | number,
    data: Partial<{
      status: AskResultStatus;
      detail: ThreadResponseDetail;
      error: WrenAIError;
    }>,
    queryOptions?: IQueryOptions,
  ) {
    const transformedData = {
      ...data,
      detail: data.detail ? JSON.stringify(data.detail) : null,
      error: data.error ? JSON.stringify(data.error) : null,
    };
    const executer = queryOptions?.tx ? queryOptions.tx : this.knex;
    const [result] = await executer(this.tableName)
      .where({ id })
      .update(transformedData)
      .returning('*');
    return this.transformFromDBData(result);
  }

  protected override transformToDBData = (data: any) => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const formattedData = mapValues(data, (value, key) => {
      if (['error', 'detail', 'corrections'].includes(key)) {
        // The value from Sqlite will be string type, while the value from PG is JSON object
        if (value) {
          return typeof value === 'string' ? value : JSON.stringify(value);
        } else {
          return value;
        }
      }
      return value;
    }) as Dictionary<any>;
    return mapKeys(formattedData, (_value, key) => snakeCase(key));
  };

  protected override transformFromDBData = (data: any): ThreadResponse => {
    if (!isPlainObject(data)) {
      throw new Error('Unexpected dbdata');
    }
    const camelCaseData = mapKeys(data, (_value, key) => camelCase(key));
    const formattedData = mapValues(camelCaseData, (value, key) => {
      if (['error', 'detail', 'corrections'].includes(key)) {
        // The value from Sqlite will be string type, while the value from PG is JSON object
        if (typeof value === 'string') {
          return value ? JSON.parse(value) : value;
        } else {
          return value;
        }
      }
      return value;
    }) as ThreadResponse;
    return formattedData;
  };
}
