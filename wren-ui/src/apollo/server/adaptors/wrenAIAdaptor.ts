import axios from 'axios';
import { Manifest } from '@server/mdl/type';
import { getLogger } from '@server/utils';
import * as Errors from '@server/utils/error';

const logger = getLogger('WrenAIAdaptor');
logger.level = 'debug';

export interface WrenAIError {
  code: Errors.GeneralErrorCodes;
  message: string;
}

export enum WrenAIDeployStatusEnum {
  SUCCESS = 'SUCCESS',
  FAILED = 'FAILED',
}

export interface WrenAIDeployResponse {
  status: WrenAIDeployStatusEnum;
  error?: string;
}

enum WrenAISystemStatus {
  INDEXING = 'INDEXING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
}

export interface deployData {
  manifest: Manifest;
  hash: string;
}

// ask
export interface AskStep {
  summary: string;
  sql: string;
  cteName: string;
}

export interface AskHistory {
  sql: string;
  summary: string;
  steps: Array<AskStep>;
}

export interface AskInput {
  query: string;
  deployId: string;
  history?: AskHistory;
}

export interface AsyncQueryResponse {
  queryId: string;
}

export type ExplainResult = AIServiceResponse<any, ExplainPipelineStatus>;

export enum ExplainPipelineStatus {
  UNDERSTANDING = 'UNDERSTANDING',
  GENERATING = 'GENERATING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
}

export enum AskResultStatus {
  UNDERSTANDING = 'UNDERSTANDING',
  SEARCHING = 'SEARCHING',
  GENERATING = 'GENERATING',
  FINISHED = 'FINISHED',
  FAILED = 'FAILED',
  STOPPED = 'STOPPED',
}

export interface StepAnalysisResult {
  sql: string;
  summary: string;
  sql_analysis_results: any;
}

// if it's view, viewId will be returned as well. It means the candidate is originally saved in mdl as a view.
// if it's llm, viewId will not be returned. It means the candidate is generated by AI service.
export enum AskCandidateType {
  VIEW = 'VIEW',
  LLM = 'LLM',
}

// The enum key's name refer to schema.ts > ReferenceType
// It helps mapping AI service enum values: selectItems, relation, filter, sortings, groupByKeys
export enum ExplanationType {
  FIELD = 'selectItems',
  QUERY_FROM = 'relation',
  FILTER = 'filter',
  SORTING = 'sortings',
  GROUP_BY = 'groupByKeys',
}

// UI currently only support nl_expression
export enum ExpressionType {
  SQL_EXPRESSION = 'sql_expression',
  NL_EXPRESSION = 'nl_expression',
}

export interface AIServiceResponse<R, S> {
  status: S;
  response: R | null;
  error: WrenAIError | null;
}

export interface AskDetailInput {
  query: string;
  sql: string;
  summary: string;
}

export type AskDetailResult = AIServiceResponse<
  {
    description: string;
    steps: AskStep[];
  },
  AskResultStatus
>;

export type AskResult = AIServiceResponse<
  Array<{
    type: AskCandidateType;
    sql: string;
    summary: string;
    viewId?: number | null;
  }>,
  AskResultStatus
>;

export interface CorrectionObject<T> {
  type: T;
  value: string;
}

export interface AskCorrectionInput {
  before: CorrectionObject<ExplanationType>;
  after: CorrectionObject<ExpressionType>;
}

export interface AskStepWithCorrectionsInput {
  summary: string;
  sql: string;
  cte_name: string;
  corrections: AskCorrectionInput[];
}

export interface RegenerateAskDetailInput {
  description: string;
  steps: AskStepWithCorrectionsInput[];
}

const getAIServiceError = (error: any) => {
  const { data } = error.response || {};
  return data?.detail
    ? `${error.message}, detail: ${data.detail}`
    : error.message;
};

export interface IWrenAIAdaptor {
  deploy(deployData: deployData): Promise<WrenAIDeployResponse>;

  /**
   * Ask AI service a question.
   * AI service will return anwser candidates containing sql and summary.
   * 1. use ask() to ask a question, AI service will return a queryId
   * 2. use getAskResult() to get the result of the queryId
   * 3. use cancelAsk() to cancel the query
   **/
  ask(input: AskInput): Promise<AsyncQueryResponse>;
  cancelAsk(queryId: string): Promise<void>;
  getAskResult(queryId: string): Promise<AskResult>;

  /**
   * After you choose a candidate, you can request AI service to generate the detail.
   * 1. use generateAskDetail() to generate the detail. AI service will return a queryId
   * 2. use getAskDetailResult() to get the result of the queryId
   */
  generateAskDetail(input: AskDetailInput): Promise<AsyncQueryResponse>;
  getAskDetailResult(queryId: string): Promise<AskDetailResult>;
  explain(
    question: string,
    stepAnalysisResult: StepAnalysisResult[],
  ): Promise<AsyncQueryResponse>;
  getExplainResult(queryId: string): Promise<ExplainResult>;
  regenerateAskDetail(
    input: RegenerateAskDetailInput,
  ): Promise<AsyncQueryResponse>;
  getRegeneratedAskDetailResult(queryId: string): Promise<AskDetailResult>;
}

export class WrenAIAdaptor implements IWrenAIAdaptor {
  private readonly wrenAIBaseEndpoint: string;

  constructor({ wrenAIBaseEndpoint }: { wrenAIBaseEndpoint: string }) {
    this.wrenAIBaseEndpoint = wrenAIBaseEndpoint;
  }

  /**
   * Ask AI service a question.
   * AI service will return anwser candidates containing sql and summary.
   */

  public async ask(input: AskInput): Promise<AsyncQueryResponse> {
    try {
      const res = await axios.post(`${this.wrenAIBaseEndpoint}/v1/asks`, {
        query: input.query,
        id: input.deployId,
        history: this.transformHistoryInput(input.history),
      });
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(`Got error when asking wren AI: ${getAIServiceError(err)}`);
      throw err;
    }
  }

  public async cancelAsk(queryId: string): Promise<void> {
    // make PATCH request /v1/asks/:query_id to cancel the query
    try {
      await axios.patch(`${this.wrenAIBaseEndpoint}/v1/asks/${queryId}`, {
        status: 'stopped',
      });
    } catch (err: any) {
      logger.debug(`Got error when canceling ask: ${getAIServiceError(err)}`);
      throw err;
    }
  }

  public async getAskResult(queryId: string): Promise<AskResult> {
    // make GET request /v1/asks/:query_id/result to get the result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/asks/${queryId}/result`,
      );
      return this.transformAskResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting ask result: ${getAIServiceError(err)}`,
      );
      // throw err;
      throw Errors.create(Errors.GeneralErrorCodes.INTERNAL_SERVER_ERROR, {
        originalError: err,
      });
    }
  }

  public async explain(
    question: string,
    stepAnalysisResult: StepAnalysisResult[],
  ): Promise<AsyncQueryResponse> {
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/sql-explanations`,
        {
          question,
          steps_with_analysis_results: stepAnalysisResult,
        },
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(`Got error when explaining: ${getAIServiceError(err)}`);
      throw err;
    }
  }

  public async getExplainResult(queryId: string): Promise<ExplainResult> {
    // make GET request /v1/sql-explanations/:query_id/result to get the result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/sql-explanations/${queryId}/result`,
      );
      const { status, error } = this.transformStatusAndError(res.data);
      return {
        status: status as ExplainPipelineStatus,
        response: res.data.response,
        error,
      };
    } catch (err: any) {
      logger.debug(
        `Got error when getting explain result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  /**
   * After you choose a candidate, you can request AI service to generate the detail.
   */

  public async generateAskDetail(
    input: AskDetailInput,
  ): Promise<AsyncQueryResponse> {
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/ask-details`,
        input,
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(
        `Got error when generating ask detail: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async getAskDetailResult(queryId: string): Promise<AskDetailResult> {
    // make GET request /v1/ask-details/:query_id/result to get the result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/ask-details/${queryId}/result`,
      );
      return this.transformAskDetailResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting ask detail result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async regenerateAskDetail(input: RegenerateAskDetailInput) {
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/sql-regenerations`,
        input,
      );
      return { queryId: res.data.query_id };
    } catch (err: any) {
      logger.debug(
        `Got error when regenerating ask detail: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async getRegeneratedAskDetailResult(queryId: string) {
    // make GET request /v1/sql-regenerations/:query_id/result to get the result
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/sql-regenerations/${queryId}/result`,
      );
      return this.transformAskDetailResult(res.data);
    } catch (err: any) {
      logger.debug(
        `Got error when getting regenerated ask detail result: ${getAIServiceError(err)}`,
      );
      throw err;
    }
  }

  public async deploy(deployData: deployData): Promise<WrenAIDeployResponse> {
    const { manifest, hash } = deployData;
    try {
      const res = await axios.post(
        `${this.wrenAIBaseEndpoint}/v1/semantics-preparations`,
        { mdl: JSON.stringify(manifest), id: hash },
      );
      const deployId = res.data.id;
      logger.debug(
        `Wren AI: Deploying wren AI, hash: ${hash}, deployId: ${deployId}`,
      );
      const deploySuccess = await this.waitDeployFinished(deployId);
      if (deploySuccess) {
        logger.debug(`Wren AI: Deploy wren AI success, hash: ${hash}`);
        return { status: WrenAIDeployStatusEnum.SUCCESS };
      } else {
        return {
          status: WrenAIDeployStatusEnum.FAILED,
          error: `Wren AI: Deploy wren AI failed or timeout, hash: ${hash}`,
        };
      }
    } catch (err: any) {
      logger.debug(
        `Got error when deploying to wren AI, hash: ${hash}. Error: ${err.message}`,
      );
      return {
        status: WrenAIDeployStatusEnum.FAILED,
        error: `Wren AI Error: deployment hash:${hash}, ${err.message}`,
      };
    }
  }

  private async waitDeployFinished(deployId: string): Promise<boolean> {
    let deploySuccess = false;
    // timeout after 30 seconds
    for (let waitTime = 1; waitTime <= 7; waitTime++) {
      try {
        const status = await this.getDeployStatus(deployId);
        logger.debug(`Wren AI: Deploy status: ${status}`);
        if (status === WrenAISystemStatus.FINISHED) {
          deploySuccess = true;
          break;
        } else if (status === WrenAISystemStatus.FAILED) {
          break;
        } else if (status === WrenAISystemStatus.INDEXING) {
          // do nothing
        } else {
          logger.debug(`Wren AI: Unknown Wren AI deploy status: ${status}`);
          return;
        }
      } catch (err: any) {
        throw err;
      }
      await new Promise((resolve) => setTimeout(resolve, waitTime * 1000));
    }
    return deploySuccess;
  }

  private async getDeployStatus(deployId: string): Promise<WrenAISystemStatus> {
    try {
      const res = await axios.get(
        `${this.wrenAIBaseEndpoint}/v1/semantics-preparations/${deployId}/status`,
      );
      if (res.data?.error?.message) {
        // passing AI response error string to catch block
        throw new Error(res.data.error.message);
      }
      return res.data?.status.toUpperCase() as WrenAISystemStatus;
    } catch (err: any) {
      logger.debug(
        `Got error in API /v1/semantics-preparations/${deployId}/status: ${err.message}`,
      );
      throw err;
    }
  }

  private transformAskResult(body: any): AskResult {
    const { status, error } = this.transformStatusAndError(body);
    const candidates = (body?.response || []).map((candidate: any) => ({
      type: candidate?.type?.toUpperCase() as AskCandidateType,
      sql: candidate.sql,
      summary: candidate.summary,
      viewId: candidate?.viewId ? Number(candidate.viewId) : null,
    }));

    return {
      status: status as AskResultStatus,
      error,
      response: candidates,
    };
  }

  private transformAskDetailResult(body: any): AskDetailResult {
    const { status, error } = this.transformStatusAndError(body);

    // snake_case to camelCase
    const steps = (body?.response?.steps || []).map((step: any) => ({
      summary: step.summary,
      sql: step.sql,
      cteName: step.cte_name,
    }));

    return {
      status: status as AskResultStatus,
      error,
      response: {
        description: body?.response?.description,
        steps,
      },
    };
  }

  private transformStatusAndError(body: any): {
    status: AskResultStatus | ExplainPipelineStatus;
    error?: {
      code: Errors.GeneralErrorCodes;
      message: string;
      shortMessage: string;
    } | null;
  } {
    // transform status to enum
    const status =
      (AskResultStatus[body?.status?.toUpperCase()] as AskResultStatus) ||
      (ExplainPipelineStatus[
        body.status
      ]?.toUpperCase() as ExplainPipelineStatus);

    if (!status) {
      throw new Error(`Unknown ask status: ${body?.status}`);
    }

    // use custom error to transform error
    const code = body?.error?.code;
    const error = code
      ? Errors.create(
          code,
          code === Errors.GeneralErrorCodes.AI_SERVICE_UNDEFINED_ERROR
            ? {
                customMessage: body?.error?.message,
              }
            : undefined,
        )
      : null;

    // format custom error into WrenAIError that is used in graphql
    const formattedError = error
      ? {
          code: error.extensions.code as Errors.GeneralErrorCodes,
          message: error.message,
          shortMessage: error.extensions.shortMessage as string,
        }
      : null;

    return {
      status,
      error: formattedError,
    };
  }

  private transformHistoryInput(history: AskHistory) {
    if (!history) {
      return null;
    }

    // make it snake_case
    return {
      ...history,
      steps: history.steps.map((step) => ({
        sql: step.sql,
        summary: step.summary,
        cte_name: step.cteName,
      })),
    };
  }
}
